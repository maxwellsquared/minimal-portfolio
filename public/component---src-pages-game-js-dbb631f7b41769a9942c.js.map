{"version":3,"file":"component---src-pages-game-js-dbb631f7b41769a9942c.js","mappings":"uMAumBaA,EAAO,WAAH,OAAS,+CAA+B,EAEzD,UArmBa,WACT,OACI,gBAAC,IAAM,CAACC,UAAU,mBACd,+BACI,60BAgBA,gBAAC,EAAAC,EAAW,CACRC,MAAM,MACNC,IAAI,4EACJC,IAAI,4FAA2F,sBAEnG,wNAOA,sDAEA,8CAEA,ghBAYA,sOAMA,0BACI,yEACA,4JAKA,sEACA,gDAGJ,+UASA,yDAEA,uLAMA,kdAWA,wLAKA,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,4DACJC,IAAI,gGAA+F,qBAGvG,0WASA,oVASA,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,8CACJC,IAAI,kGAAiG,sBAGzG,2TAOA,4BACK,IAAG,iBACU,2BAAM,IAEpB,2BACC,IAAQ,4CAA0C,2BAAO,IAC1D,2BACC,IAAQ,6CACT,2BACC,IAAQ,+CACT,2BACC,IAAQ,qDACT,2BACC,IAAQ,uCACT,2BAAM,KAIV,ubAUA,oKAKA,kGAGI,2BAAM,gCAEN,2BAAM,iCACwB,2BAAM,8DACwB,IAC5D,4BAEJ,yBACK,IAAG,kYASR,ooBAaA,iSAOA,qDAEI,2BAAM,IAEN,2BACC,IAAQ,qBACT,2BAAM,IAEN,4BAGJ,qJAMA,sKAKA,4DACA,0VASA,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,iCACJC,IAAI,uGAAsG,sBAG9G,wLAKA,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,kCACJC,IAAI,uGAAsG,sBAE9G,gUAQA,sCAEA,yJAMA,qpBAcA,kZAUA,uEAEA,oDACyB,2BAAM,IAE3B,2BACC,IAAQ,kHAGT,2BACC,IAAQ,2FAGT,2BACC,IAAQ,0FAET,2BACC,IAAQ,0CACT,2BAAM,KAIV,uiBAWA,6CAEA,0QAOA,0JAKA,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,8DACJC,IAAI,kGAAiG,2eAEzG,+bAWA,gjBAYA,oDACA,6pBAeA,4fAYA,sMAKA,wFAEI,2BAAM,IAEN,2BACC,IAAQ,iDACT,2BACC,IAAQ,wBACT,2BACC,IAAQ,6BACT,2BACC,IAAQ,IACT,2BACC,IACA,IAAQ,+CACT,2BACC,IACA,IAAQ,+CACT,2BACA,2BACC,IACA,IAAQ,8DAET,2BACC,IACA,IAAQ,6BACT,2BACA,2BACC,IACA,IAAQ,yFAC2B,2BACnC,IACA,IAAQ,qBACT,2BACC,IAAQ,IACT,2BACA,2BACC,IAAQ,yCACT,2BAAM,IAEN,4BAGJ,y2BAmBA,oYAUA,+HAIA,wDAEA,4dAWA,qXASA,sIAKA,2DAEA,iNAOA,0PAOA,obAUA,8PAOA,4KAMA,sDAEA,wfAYA,2UASA,8CAEA,gTAMI,gBAAC,EAAAH,EAAW,CACRC,MAAM,MACNC,IAAI,kEACJC,IAAI,4FAA2F,sBACjG,oOAMN,wCACA,+WASA,wCACA,+WAWhB,C","sources":["webpack://minimal-portfolio/./src/pages/game.js"],"sourcesContent":["import * as React from \"react\";\r\nimport Layout from \"../components/layout\";\r\nimport { StaticImage } from \"gatsby-plugin-image\";\r\n\r\nconst Game = () => {\r\n    return (\r\n        <Layout pageTitle=\"Building a Game\">\r\n            <section>\r\n                <p>\r\n                    Over the past year, I've fallen in love with a new kind of\r\n                    video game: something halfway between a traditional indie\r\n                    roguelike and a classic arcade game (take your pick of\r\n                    \"classic\": Newgrounds flash titles, 1980s coin-op games, or\r\n                    mobile games from the early App Store era). These things are\r\n                    snackable, usually with simple graphics (Vampire Survivors,\r\n                    probably the biggest example of the genre, started with art\r\n                    from an asset pack) and satisfying mechanics that offer some\r\n                    kind of persistent upgrades as incentive to complete\r\n                    bite-sized runs. If triple-A games are bloated early-70s\r\n                    prog rock albums, these games are the first Ramones album:\r\n                    29 minutes long, recorded in a week for $6400, and nothing\r\n                    but bangers. Like that Ramones album, the best part is that\r\n                    it makes you think, “Hey, I could do this,” so I did.\r\n                </p>\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"Video game where a ship flies around a planet and shoots glowing targets.\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/Gameplay-2.png?raw=true\"\r\n                />\r\n                <p>\r\n                    Or, at least, I'm doing it. It's not done yet: I still have\r\n                    a lot of features to add, but you can fly a ship around and\r\n                    shoot things with mostly complete effects and controls and\r\n                    scoring.\r\n                </p>\r\n\r\n                <p>Here's my process so far.</p>\r\n\r\n                <h2>Initial Planning</h2>\r\n\r\n                <p>\r\n                    I started by thinking about a simple gameplay loop I was\r\n                    reasonably sure I could accomplish in a few weeks while\r\n                    teaching myself some new programming concepts. I've been\r\n                    wanting to build a Survivors-like for a while; the mechanics\r\n                    are simple yet satisfying, and I can think of a ton of ways\r\n                    to tweak them slightly and end up with a whole new game. I\r\n                    decided that combining bullet-heaven-style upgrades with\r\n                    rail shooting à la Star Fox 64 would be something fun,\r\n                    original, and within my capabilities.\r\n                </p>\r\n\r\n                <p>\r\n                    I find when building projects that my favourite approach is\r\n                    to start with a minimum viable product and then add features\r\n                    and functionality. Eventually, I settled on the following\r\n                    objectives for my MVP:\r\n                </p>\r\n                <ul>\r\n                    <li>Have a rail system moving the camera along…</li>\r\n                    <li>\r\n                        …where the player can move horizontally and vertically\r\n                        while the gameplay plane moves through the level (think\r\n                        Star Fox 64)...\r\n                    </li>\r\n                    <li>And can fire bullets in a straight line…</li>\r\n                    <li>To kill bad guys.</li>\r\n                </ul>\r\n\r\n                <p>\r\n                    I know that I tend to get caught up having fun with details,\r\n                    and adding a bunch of cool weapons and upgraded stats was\r\n                    something that I'd absolutely get bogged down in. I'm\r\n                    looking forward to setting that up after the initial\r\n                    mechanics are rock-solid, but for now I'm keeping the\r\n                    roguelike stuff for later.\r\n                </p>\r\n\r\n                <h2>Gameplay Plane and Movement</h2>\r\n\r\n                <p>\r\n                    My first task was to implement a gameplay plane that moved\r\n                    along on rails, with the player able to control horizontal\r\n                    and vertical movement of their ship.\r\n                </p>\r\n\r\n                <p>\r\n                    One of my first big design decisions was that I wanted the\r\n                    player to move in a loop through the level instead of having\r\n                    a linear track with a beginning and end. I liked the idea of\r\n                    the player's progress being measured in terms of time, not\r\n                    space--it would make playing the same levels over and over\r\n                    feel more natural, and it meant that I could design my\r\n                    levels without needing to keep tight integration with the\r\n                    rest of what I was doing.\r\n                </p>\r\n\r\n                <p>\r\n                    This did mean that I'd need to make sure that when the rail\r\n                    for my rail shooter made a turn, I'd have to keep the player\r\n                    and camera pointing the right way:\r\n                </p>\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"Game interface on a track with a camera and a rocket ship\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/track-movement.png?raw=true\"\r\n                />\r\n\r\n                <p>\r\n                    I decided the easiest solution for this would be to put\r\n                    everything into a GameplayPlane object which I would send\r\n                    down a track. Inside the GameplayPlane would be the camera,\r\n                    player, and anything else I needed. I would use local values\r\n                    like transform.localPosition to move things relative to the\r\n                    mine cart everything was crammed into.\r\n                </p>\r\n\r\n                <p>\r\n                    I also decided to use Cinemachine's dolly track and dolly\r\n                    cart to build my track--I found a Mix and Jam video where\r\n                    they used this setup and it looked like it would fit my\r\n                    needs nicely, so I stole the idea. The track system is very\r\n                    handy and let me easily set up a track around the terrain\r\n                    I'd quickly sculpted.\r\n                </p>\r\n\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"Unity interface showing a track and terrain\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/track-movement-2.png?raw=true\"\r\n                />\r\n\r\n                <p>\r\n                    It came paired with a dolly cart, and I put a reference to\r\n                    that cart in the GameplayPlane script. Once per frame (on\r\n                    Update()), the GameplayPlane object would move itself to\r\n                    wherever the dollyCart was and match the dollyCart's\r\n                    side-to-side rotation. Here's what that looks like in code:\r\n                </p>\r\n                <code>\r\n                    {\" \"}\r\n                    void Update() <br />\r\n                    &#123;\r\n                    <br />\r\n                    {\"\\u00A0\"}transform.position = dollyCart.position; <br />{\" \"}\r\n                    <br />\r\n                    {\"\\u00A0\"}// match dollycart's side-to-side rotation\r\n                    <br />\r\n                    {\"\\u00A0\"}Vector3 newRotation = transform.eulerAngles;\r\n                    <br />\r\n                    {\"\\u00A0\"}newRotation.y = dollyCart.transform.eulerAngles.y;\r\n                    <br />\r\n                    {\"\\u00A0\"}transform.eulerAngles = newRotation;\r\n                    <br />\r\n                    &#125;\r\n                </code>\r\n\r\n                <p>\r\n                    All the other stuff in the cart, being children, would\r\n                    automatically be moved and rotated as well. The player\r\n                    object also got a function to move horizontally or\r\n                    vertically: if joystick or mouse input was detected, it\r\n                    would put that input into a variable h or v and pass it\r\n                    along to a LocalMove function along with a speed value,\r\n                    which added those variables as a Vector3 to the object's\r\n                    transform.localPosition.\r\n                </p>\r\n                <p>\r\n                    Next in LocalMove(), a ClampPosition() function would be\r\n                    called which clamps the player object's position within the\r\n                    camera's viewport:\r\n                </p>\r\n                <code>\r\n                    Vector3 pos =\r\n                    Camera.main.WorldToViewportPoint(transform.position);\r\n                    <br />\r\n                    pos.x = Mathf.Clamp01(pos.x);\r\n                    <br />\r\n                    pos.y = Mathf.Clamp01(pos.y); <br />\r\n                    transform.position = Camera.main.ViewportToWorldPoint(pos);{\" \"}\r\n                    <br />\r\n                </code>\r\n                <p>\r\n                    {\" \"}\r\n                    Camera.main returns the main camera in the scene, and the\r\n                    WorldToViewportPoint() method takes in a world space\r\n                    coordinate and returns a corresponding coordinate in\r\n                    normalized viewport space. This means that the pos variable\r\n                    will have values between 0 and 1 for both the x and y axes,\r\n                    where (0,0) is the bottom-left corner of the camera's\r\n                    viewport, and (1,1) is the top-right corner.\r\n                </p>\r\n                <p>\r\n                    First we declare a Vector3 variable named “pos” and assign\r\n                    to it the position of the object in Camera.main's normalized\r\n                    viewport space. The bottom-left corner of the camera\r\n                    viewport is (0,0) and the top-right corner is (1,1), so we\r\n                    use Mathf.Clamp01 to make sure both our x and y values for\r\n                    our pos variable are between 0 and 1. We take our normalized\r\n                    pos variable and use the ViewportToWorldPoint() function on\r\n                    our main camera to turn those viewport space coordinates\r\n                    into world coordinates, and then we pass that into\r\n                    transform.position to move our object in the world to a nice\r\n                    safe location within our viewport.\r\n                </p>\r\n                <p>\r\n                    The end result is a flat plane that the player can move\r\n                    within, travelling along a looping track. I gave my player\r\n                    object a public float forwardSpeed and a reference to the\r\n                    dolly cart so I could set the speed of the gameplay plane by\r\n                    calling a simple function:\r\n                </p>\r\n                <code>\r\n                    void SetSpeed(float x)\r\n                    <br />\r\n                    &#123;\r\n                    <br />\r\n                    {\"\\u00A0\"}dolly.m_Speed = x;\r\n                    <br />\r\n                    &#125;\r\n                    <br />\r\n                </code>\r\n\r\n                <p>\r\n                    I'd use this later to let the player boost and stop them\r\n                    when they died, but for the moment I just called it on\r\n                    Start().\r\n                </p>\r\n\r\n                <p>\r\n                    Mouse controls are still pretty bad, so the game should be\r\n                    played with a controller, but adding decent mouse controls\r\n                    is next on my list.\r\n                </p>\r\n                <h2>Making It Pretty, Pretty Early</h2>\r\n                <p>\r\n                    I'm putting it here to make it sound like I did the\r\n                    responsible thing and started by using a plain cube for\r\n                    movement until I had the mechanics down, but I was actually\r\n                    messing around in Blender way before I should have. I\r\n                    modelled a simple spaceship with a silhouette designed to\r\n                    catch the player's eye from the rear:\r\n                </p>\r\n\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"a cool spaceship from the back\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/spaceship_beauty_back.png?raw=true\"\r\n                />\r\n\r\n                <p>\r\n                    I spent less time on the front and side profile, as the\r\n                    player would only rarely see them, but was inspired by some\r\n                    of the sharp body lines on modern cars:\r\n                </p>\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"a cool spaceship from the front\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/spaceship_beauty_side.png?raw=true\"\r\n                />\r\n                <p>\r\n                    These renders are in front of the skybox that I also made\r\n                    around then, combining pictures of clouds with a starfield I\r\n                    generated from noise and some NASA public-domain images of\r\n                    planets and moons which I recolored and filtered to look\r\n                    like they were hanging in the sky above an alien planet.\r\n                </p>\r\n\r\n                <h2>Shooting</h2>\r\n\r\n                <p>\r\n                    I'd previously built an Asteroids clone in Unity, and I\r\n                    thought I would steal some of the functionality and adapt it\r\n                    for 3D.\r\n                </p>\r\n\r\n                <p>\r\n                    In Yasssteroids (my yassified Asteroids clone), I used a\r\n                    Bullet prefab with a rigidbody, a box collider, something to\r\n                    render, and a script. The script has a public float for\r\n                    speed and maxLifetime. On Awake() it figures out where its\r\n                    rigidbody is and makes a reference to it; its big trick is a\r\n                    method called Project(Vector2 direction) which adds force to\r\n                    that rigidbody using the direction provided as well as its\r\n                    speed value, then calls Destroy on itself after its max\r\n                    lifetime. It also has an OnCollisionEnter2D method which\r\n                    just destroys it: targets check if they're hit by bullets,\r\n                    bullets don't check if they're hit by targets.\r\n                </p>\r\n\r\n                <p>\r\n                    Over in the player object, I made a Shoot() method which\r\n                    sets a vector for the current position plus an offset to get\r\n                    around collision issues. I then instantiate a new bullet\r\n                    using the bullet prefab, the variable I just made for the\r\n                    position, and the player's rotation before calling that\r\n                    bullet's Project() method and passing in the\r\n                    transform.forward of the parent object.\r\n                </p>\r\n\r\n                <p>It was fairly simple to adapt this for 3D:</p>\r\n\r\n                <code>\r\n                    private void Shoot() <br />\r\n                    &#123;\r\n                    <br />\r\n                    {\"\\u00A0\"}Vector3 shootPos = new\r\n                    Vector3(transform.position.x, transform.position.y,\r\n                    transform.position.z + shootOffset);\r\n                    <br />\r\n                    {\"\\u00A0\"}PlayerBullet bullet =\r\n                    Instantiate(this.bulletPrefab, shootPos,\r\n                    this.transform.rotation);\r\n                    <br />\r\n                    {\"\\u00A0\"}Physics.IgnoreCollision(bullet.GetComponent&lt;\r\n                    Collider&gt; (), GetComponent&lt; Collider&gt; ());\r\n                    <br />\r\n                    {\"\\u00A0\"}bullet.Project(this.transform.forward);\r\n                    <br />\r\n                    &#125;\r\n                </code>\r\n\r\n                <p>\r\n                    The biggest issue that I ran into was that I had a rigidbody\r\n                    and a collider on the bullets, and I had a rigidbody and a\r\n                    collider on my player spaceship to prepare it for detecting\r\n                    collisions with the ground. The ship would sometimes collide\r\n                    with bullets occasionally; I was planning on just spawning\r\n                    bullets out of the player collider using the offset I\r\n                    mentioned previously, but I decided it would be better to\r\n                    simply set up a Physics.IgnoreCollision() between the\r\n                    collider in the player object and the one in the bullet.\r\n                </p>\r\n                <h2>My Many Enemies</h2>\r\n\r\n                <p>\r\n                    To make sure the rest of the mechanics were solid, I chose\r\n                    to start with simple static targets as enemies. I modelled\r\n                    these targets in Blender, and used very few polygons to make\r\n                    sure I could use a mesh collider without too much trouble.\r\n                </p>\r\n\r\n                <p>\r\n                    My eventual plan is for the enemies to essentially travel\r\n                    around the same track as the player, but in the opposite\r\n                    direction:\r\n                </p>\r\n                <StaticImage\r\n                    width=\"600\"\r\n                    alt=\"diagram of two spaceships on a track, pointed at each other\"\r\n                    src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/track_movement_3.png?raw=true\"\r\n                />\r\n                <p>\r\n                    I spawn enemies with a dolly cart called EnemyCart. It's a\r\n                    dolly going on the same track as the player but backwards,\r\n                    with a script that initialises an enemy every few seconds at\r\n                    a random offset from the track. This means that as the\r\n                    player moves along the track, they will constantly fly into\r\n                    enemies. For now, it spawns static targets, but it will\r\n                    eventually spawn different kinds of enemies who move and\r\n                    shoot back.\r\n                </p>\r\n\r\n                <p>\r\n                    These static targets are based on a prefab which references\r\n                    my GameManager and a particle system prefab called\r\n                    “Splosion.” It has an OnCollisionEnter which, if it collides\r\n                    with a target and the colliding object has the\r\n                    “PlayerBullet” tag, spawns the Splosion particle system,\r\n                    calls a method on the GameManager which adds one to the\r\n                    score, and then destroys itself. The splosion prefab,\r\n                    helpfully, has a particle system which automatically\r\n                    destroys itself once the animation finishes so I don't have\r\n                    to do any fancy scripting to it.\r\n                </p>\r\n                <h2>Boost and Camera Shake</h2>\r\n                <p>\r\n                    I added boost to the PlayerController script by checking in\r\n                    Update() if the player was pressing the B button on the\r\n                    gamepad. When the B button is first pushed, isBoosting is\r\n                    set to true, SetSpeed() is called with forwardSpeed * 2 as\r\n                    an argument, and a looping particle system called\r\n                    boostParticles starts playing. The particle system is a game\r\n                    object which is a child of the Player object, and when boost\r\n                    starts, the player object calls the .Play() method on its\r\n                    reference to the boostParticles object. When the B button\r\n                    goes up, isBoosting is set to false, speed returns to\r\n                    forwardSpeed, and the .Stop() method is called on\r\n                    boostParticles.\r\n                </p>\r\n\r\n                <p>\r\n                    To make it clear that the player was going really fast, I\r\n                    added a reference to the virtual camera I'd included in the\r\n                    GameplayPlane, and at the start of Update() set that virtual\r\n                    camera's m_Lens.FieldOfView to a variable which I increased\r\n                    over time (if not boosting, that variable decreases over\r\n                    time). The code for this is all still pretty messy, and one\r\n                    of the next things I do is going to be to break it into\r\n                    separate functions instead of just cramming Update() full of\r\n                    stuff.\r\n                </p>\r\n\r\n                <p>\r\n                    It wasn't enough, though, and I realized that the boost\r\n                    function needed camera shake. I had to use a coroutine to\r\n                    implement this in the script I put on my camera object:\r\n                </p>\r\n                <code>\r\n                    public IEnumerator Shake(float duration, float magnitude)\r\n                    <br />\r\n                    &#123;\r\n                    <br />\r\n                    {\"\\u00A0\"}Vector3 originalPos = transform.localPosition;\r\n                    <br />\r\n                    {\"\\u00A0\"}float elapsed = 0.0f;\r\n                    <br />\r\n                    {\"\\u00A0\"}while (elapsed &lt; duration)\r\n                    <br />\r\n                    {\"\\u00A0\"}&#123;\r\n                    <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}float x = Random.Range(-1f, 1f) * magnitude;\r\n                    <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}float y = Random.Range(-1f, 1f) * magnitude;\r\n                    <br />\r\n                    <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}transform.localPosition = new Vector3(x, y,\r\n                    originalPos.z);\r\n                    <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}elapsed += Time.deltaTime;\r\n                    <br />\r\n                    <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}// before continuing to the next iteration of the\r\n                    while loop, wait for the next frame <br />\r\n                    {\"\\u00A0\"}\r\n                    {\"\\u00A0\"}yield return null;\r\n                    <br />\r\n                    {\"\\u00A0\"}&#125;\r\n                    <br />\r\n                    <br />\r\n                    {\"\\u00A0\"}transform.localPosition = originalPos;\r\n                    <br />\r\n                    &#125;\r\n                    <br />\r\n                </code>\r\n\r\n                <p>\r\n                    Our Shake function is a coroutine--an ongoing thing that\r\n                    lets you pause and pick up where you left off, which makes\r\n                    running a bunch of things at the same time easier. This\r\n                    mostly means that calling it is a little weird (in the\r\n                    player object, instead of just calling\r\n                    cameraShake.Shake(duration, magnitude) I have to use\r\n                    StartCoroutine(cameraShake.Shake(duration, magnitude)), at\r\n                    the top it says IEnumerator, and I can put yield return null\r\n                    in my while loop to have Unity put a bookmark in what it's\r\n                    doing and pick it up on the next frame. The rest of the\r\n                    function just sets a variable to the original local position\r\n                    of the object and another one to an elapsed time of zero,\r\n                    then moves the camera's localPosition around slightly\r\n                    (amplified by the magnitude passed in) until the proper\r\n                    duration is hit, at which point it resets its local\r\n                    position.\r\n                </p>\r\n\r\n                <p>\r\n                    For this Shake coroutine, I shake the camera on the local x\r\n                    and y axes, but I decided to add a little camera knockback\r\n                    to make the player's shots feel bigger, so I copied the\r\n                    coroutine but only moved along the Z axis to simulate\r\n                    recoil. I then started this coroutine (with a smaller\r\n                    magnitude and shorter duration) every time the player object\r\n                    called Shoot().\r\n                </p>\r\n\r\n                <p>\r\n                    Both of these uses of camera shake make the game feel much\r\n                    more responsive to the player's inputs.\r\n                </p>\r\n                <h2>Game Logic and MVC Pattern</h2>\r\n\r\n                <p>\r\n                    At this point, the game was starting to get relatively\r\n                    complicated, and I had a lot of features yet to implement! I\r\n                    decided to attempt a model-view-controller pattern to stay\r\n                    organized. I would have a GameManager object to serve as a\r\n                    model, keeping the score and business logic of the game; a\r\n                    canvas which would display information to the player; and\r\n                    then the player object as a controller to take input and\r\n                    send information to the GameController.\r\n                </p>\r\n\r\n                <p>\r\n                    The GameManager currently just keeps track of the player\r\n                    score, but will include lives, upgrades, elapsed level time,\r\n                    and other player progress information in future. It keeps a\r\n                    score variable and has an UpdateScore method which takes in\r\n                    an integer, adds that integer to the score, and updates a\r\n                    scoreText UI element with the score information.\r\n                </p>\r\n\r\n                <p>\r\n                    As the game gets more complicated, organizing functionality\r\n                    like this will really start to come in handy.\r\n                </p>\r\n\r\n                <h2>Player Death and Resurrection</h2>\r\n\r\n                <p>\r\n                    I'd made some cute terrain, but it was frustrating flying\r\n                    into it and seeing that it was as hollow as a store-brand\r\n                    chocolate bunny. I needed a function to crash the player's\r\n                    ship.\r\n                </p>\r\n\r\n                <p>\r\n                    I started with another particle system to represent the\r\n                    explosion as the player's ship hit the planet (particle\r\n                    systems are fun!). I made a simple additive blend material,\r\n                    which I also applied to my boost particle system.\r\n                </p>\r\n\r\n                <p>\r\n                    Over in the player object, I made a PlayerDeath() function\r\n                    which sets some big red text in the middle of the screen to\r\n                    read “D E A D,” stops the boost particles, sets speed to\r\n                    zero, and plays the death particles. Of course, I had to add\r\n                    a big camera shake. I then invoked a PlayerRespawn()\r\n                    function I made that reversed everything, cleared the text,\r\n                    and reset the player position to right back on the track.\r\n                </p>\r\n\r\n                <p>\r\n                    I quickly realized that with the way I'd set up my control\r\n                    functions, a dead player could still move, boost, and shoot,\r\n                    so I added an isAlive variable, set it to false on death,\r\n                    and required it to operate any of the controls.\r\n                </p>\r\n\r\n                <p>\r\n                    To add a little more pizzazz, I set useGravity to true on\r\n                    the player's rigidBody and gave them an upwards pop, which\r\n                    was unrealistic but funny.\r\n                </p>\r\n\r\n                <h2>Fun with Render Textures</h2>\r\n\r\n                <p>\r\n                    I'd always thought there was something cool about\r\n                    low-resolution games played on a CRT. I tried to get a bit\r\n                    of that analog-style funk into my visuals by throwing some\r\n                    dithering and noise onto a post-processing volume, then\r\n                    adding bloom and carefully calibrating emissive textures and\r\n                    the skybox to make sure that I was getting only the stuff I\r\n                    wanted to glow. I added a tiny bit of chromatic aberration\r\n                    and lens distortion to again mimic that feel, but it was\r\n                    still lacking.\r\n                </p>\r\n\r\n                <p>\r\n                    The trick that got me what I was really looking for was\r\n                    projecting everything onto a render texture at 320 x 180\r\n                    resolution (the N64 commonly rendered games at 320x240, but\r\n                    320x180 fits a 16:9 aspect ratio and looks nice on 1080p and\r\n                    4k monitors) and turning off anti-aliasing to get nice sharp\r\n                    pixels.\r\n                </p>\r\n\r\n                <h2>Environmentalism</h2>\r\n\r\n                <p>\r\n                    To make the game world feel a little more alive, I added two\r\n                    larger dolly tracks outside the play area and brought in\r\n                    more ships I made in Blender: a small fighter craft which\r\n                    will be an enemy in future, and a massive capital ship. It\r\n                    adds some much-needed depth to the scene:\r\n                    <StaticImage\r\n                        width=\"600\"\r\n                        alt=\"lots of spaceships flying around with a big one in the distance\"\r\n                        src=\"https://github.com/maxwellsquared/minimal-portfolio/blob/main/img/Gameplay-4.png?raw=true\"\r\n                    />\r\n                    The fighters operate in small swarms, and I used the\r\n                    transform.LookAt function to rotate them at a target\r\n                    slightly ahead of them on the track, which makes them swoop\r\n                    around elegantly and hides the fact that they're on rails.\r\n                </p>\r\n                <h2>Deployment</h2>\r\n                <p>\r\n                    I decided to build the game to WebGL, which is very handy\r\n                    for getting it onto somewhere like itch.io (it's actually\r\n                    there already in prototype form--if you email me, I'll give\r\n                    you the password to try it). Being able to play the game\r\n                    with a click of a button is a huge time saver, and it's also\r\n                    a lot more convenient for people to try out.\r\n                </p>\r\n\r\n                <h2>Next Steps</h2>\r\n                <p>\r\n                    My next step is to add a bomb for players which moves along\r\n                    an arc-shaped path and detonates when it hits something. I'm\r\n                    also planning on adding sound effects and music. As you can\r\n                    tell from the screenshots, I'm also going to need to figure\r\n                    out how much post-processing I can get away with before it\r\n                    starts looking like an Xbox 360 game.\r\n                </p>\r\n            </section>\r\n        </Layout>\r\n    );\r\n};\r\n\r\nexport const Head = () => <title>Building a Game</title>;\r\n\r\nexport default Game;\r\n"],"names":["Head","pageTitle","S","width","alt","src"],"sourceRoot":""}